//Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
//Triangle 	  	Tn=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
//Pentagonal 	  	Pn=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
//Hexagonal 	  	Hn=n(2n−1) 	  	1, 6, 15, 28, 45, ...

//It can be verified that T285 = P165 = H143 = 40755.

//Find the next triangle number that is also pentagonal and hexagonal.

let isTriangle n =
  (((sqrt (8.0 * n + 1.0)) - 1.0) / 2.0) % 1.0 = 0.0

let isPentagonal n =
  (((sqrt (24.0 * n + 1.0)) + 1.0) / 6.0) % 1.0 = 0.0

let rec euler045 n =
  let hex = n*(2.0*n-1.0)
  if isTriangle hex && isPentagonal hex then
    hex
  else
    euler045 (n+1.0)
  
printfn "%A" (euler045 144.0) // hex n = 143 is the previous number
  
// the following is bullshit
  
//let limit = 10.0
//let tri = Seq.toList (Seq.unfold (fun n -> if n < limit then Some(n * (n + 1.0) / 2.0, n+1.0) else None) 0.0)
//let pent = Seq.toList (Seq.unfold (fun n -> if n < limit then Some(n * (3.0*n - 1.0) / 2.0, n+1.0) else None) 0.0)
//let hex = Seq.toList (Seq.unfold (fun n -> if n < limit then Some(n * (2.0*n - 1.0), n+1.0) else None) 0.0)

//printfn "done generating lists"
//for x in hex do //(List.filter (fun x -> (x % 2.0) = 0.0) tri) do
  //printfn "%A" x
  //if List.exists (fun z -> z = x) pent then
  //  if List.exists (fun z -> z = x) hex then
  //    printfn "%A" x
//for x in [1..limit-1] do
  //let tmp = Seq.nth x tri
  //if (Seq.exists (fun c -> c = tmp) pent) && (Seq.exists (fun c -> c = tmp) hex) then
  //  printfn "%A" tmp
//printfn "%A" (Seq.nth 285 tri)
//printfn "%A" (Seq.nth 165 pent)
//printfn "%A" (Seq.nth 143 hex)
//let tmp = Seq.nth 285 tri
//if Seq.exists (fun z -> z = tmp) pent then
//  printfn "yay"
//else
//  printfn "nay"