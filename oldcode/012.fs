// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

// Let us list the factors of the first seven triangle numbers:

//     1: 1
//     3: 1,3
//     6: 1,2,3,6
//    10: 1,2,5,10
//    15: 1,3,5,15
//    21: 1,3,7,21
//    28: 1,2,4,7,14,28

// We can see that 28 is the first triangle number to have over five divisors.

// What is the value of the first triangle number to have over five hundred divisors?


// anzahl der divisoren:
// primzahlzerlegung
// zb. [2;2;2;3;3;5] = 2^4 * 2^3 * 2^2  (zusammenmultiplizieren 2^(wie oft primzahl aufgetreten ist)

let rec primfaktorzerlegung primfaktoren n currentvalue =
  match Seq.tryFind (fun x -> n % x = 0L) [currentvalue .. (int64(sqrt(double(n))))] with
  | Some value -> (primfaktorzerlegung (Seq.append primfaktoren [value]) (n/value) value)
  | None -> (Seq.append primfaktoren [n])
    
let rec count_divisors seq =
  if (Seq.length seq) <> 0 then
    ((Seq.length (Seq.filter (fun x -> x = (Seq.head seq)) seq))+1) * (count_divisors (Seq.filter (fun x -> x <> (Seq.head seq)) seq)) 
  else
    1

let mutable prev = (primfaktorzerlegung [] 4L 2L)
let mutable curr = (primfaktorzerlegung [] 5L 2L)
let mutable i = 5L
let mutable count = 0
while count < 500 do
  i <- i+1L
  prev <- curr
  curr <- (primfaktorzerlegung [] i 2L)
  count <- (count_divisors (Seq.skip 1 (Seq.sort (Seq.append curr prev))))

printfn "(%A * %A)/2 = %A {%A}" (i-1L) i ((i-1L)*i/2L) (count_divisors (Seq.skip 1 (Seq.sort (Seq.append curr prev))))